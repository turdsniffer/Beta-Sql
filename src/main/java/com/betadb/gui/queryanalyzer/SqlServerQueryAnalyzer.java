/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.betadb.gui.queryanalyzer;

import com.betadb.gui.connection.DbConnection;
import com.betadb.gui.datasource.DataSourceManager;
import com.betadb.gui.dbobjects.DbInfo;
import com.betadb.gui.jdbc.util.ResultSetUtils;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

/**
 *
 * @author parmstrong
 */
public class SqlServerQueryAnalyzer extends QueryAnalyzer
{
	private DbConnection connectionInfo;
	private DataSource ds;
	private JdbcTemplate jdbcTemplate;
	private DbInfo dbInfo;
	List<PlanRow> statementRoots;
	private int maxXDepth;

	@Inject DataSourceManager dataSourceManager;

	/**
	 * Creates new form SqlServerQueryAnalyzer
	 */
	public SqlServerQueryAnalyzer()
	{
		initComponents();
		statementRoots = Lists.newArrayList();
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
	 * content of this method is always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
	@Override
	public void analyze(String sql)
	{
		jdbcTemplate.execute("use " + dbInfo.getDbName());
		jdbcTemplate.execute("set showplan_all on");
		List<PlanRow> planRows = jdbcTemplate.query(sql, new RowMapper<PlanRow>()
		{
			@Override
			public PlanRow mapRow(ResultSet rs, int i) throws SQLException
			{
				PlanRow planRow = new PlanRow();
				planRow.stmtText = rs.getString("StmtText");
				planRow.stmtId = rs.getInt("StmtId");
				planRow.nodeId = rs.getInt("NodeId");
				planRow.parent = rs.getInt("Parent");
				planRow.PhysicalOp = rs.getString("PhysicalOp");
				planRow.LogicalOp = rs.getString("LogicalOp");
				planRow.EstimateIo = rs.getDouble("EstimateIO");
				planRow.EstimateCpu = rs.getDouble("EstimateCpu");
				planRow.properties = ResultSetUtils.getRowAsProperties(rs);
				return planRow;
			}
		});

		Map<Integer, PlanRow> planRowMap = Maps.newHashMap();
		statementRoots = Lists.newArrayList();
		for (PlanRow planRow : planRows)
		{
			planRowMap.put(planRow.nodeId, planRow);
			if (planRow.parent == 0)
				statementRoots.add(planRow);
			else
				planRowMap.get(planRow.parent).children.add(planRow);
		}

		jdbcTemplate.execute("set showplan_all off");
		repaint();

	}

	@Override
	protected void paintComponent(Graphics g)
	{
		super.paintComponent(g);

		int maxYLevel = -1;
		List<GraphNode> graphNodes = Lists.newArrayList();
		for (PlanRow statementRoot : statementRoots)
			maxYLevel = generateGraphNodes(statementRoot, 0, ++maxYLevel, null, graphNodes, g);

		graphNodes(graphNodes, g);

		this.setPreferredSize(new Dimension(getXPosAtLevel(maxXDepth) + nodeWidth, getYPosAtLevel(maxYLevel)
																				   + nodeHeight));

	}

	int xLevelOffset = 200;
	int yLevelOffset = 50;
	int nodeWidth = 160;
	int nodeHeight = 40;

	private int generateGraphNodes(PlanRow planRow, int xDepth, int yLevel, GraphNode parent, List<GraphNode> graphNodeList, Graphics g)
	{
		GraphNode graphNode = new GraphNode();
		graphNode.parent = parent;
		graphNode.xPos = getXPosAtLevel(xDepth);
		graphNode.yPos = getYPosAtLevel(yLevel);
		graphNode.planRow = planRow;
		graphNodeList.add(graphNode);

		if (planRow.children.isEmpty())
		{
			if (xDepth > maxXDepth)
				maxXDepth = xDepth;
			return yLevel;
		}

		int maxYLevel = yLevel;
		for (int i = 0; i < planRow.children.size(); i++)
		{
			PlanRow child = planRow.children.get(i);
			maxYLevel = generateGraphNodes(child, xDepth + 1, maxYLevel + i, graphNode, graphNodeList, g);
		}

		return maxYLevel;
	}

	private void graphNodes(List<GraphNode> graphNodes, Graphics g)
	{
		for (GraphNode curNode : graphNodes)
		{
			PlanRow planRow = curNode.planRow;
			//Draw box
			g.setColor(Color.WHITE);
			g.fillRect(curNode.xPos, curNode.yPos, nodeWidth, nodeHeight);
			g.setColor(Color.darkGray);
			g.drawRect(curNode.xPos, curNode.yPos, nodeWidth, nodeHeight);

			//Draw text
			FontMetrics metrics = g.getFontMetrics(getFont());
			String text = planRow.PhysicalOp == null ? planRow.stmtText : planRow.PhysicalOp;
			if (text != null)
			{
				int stringWidth = metrics.stringWidth(text);
				if (stringWidth > nodeWidth)
					text = text.substring(0, 14) + "...";
				g.drawString(text, curNode.xPos + 5, curNode.yPos + (nodeHeight / 2));
			}

			//Draw connection line
			if(curNode.parent != null)
			{
				GraphNode parent = curNode.parent;
				int parentLineY = parent.yPos + nodeHeight / 2;
				int childLineY = curNode.yPos + nodeHeight / 2;
				int parentLineXEnding = parent.xPos + nodeWidth + 10;

				g.drawLine(parent.xPos + nodeWidth, parentLineY, parentLineXEnding, parentLineY);
				g.drawLine(parentLineXEnding, parentLineY, parentLineXEnding, childLineY);
				g.drawLine(parentLineXEnding, childLineY, curNode.xPos, childLineY);
			}
		}
	}

	private class GraphNode
	{
		PlanRow planRow;
		int xPos;
		int yPos;
		GraphNode parent;

	}

	public int getXPosAtLevel(int xDepth)
	{
		return xDepth * xLevelOffset;
	}

	public int getYPosAtLevel(int yDepth)
	{
		return yDepth * yLevelOffset;
	}

	public void setDbInfo(DbConnection connectionInfo)
	{

		ds = dataSourceManager.getDataSourceByDbId(connectionInfo.getDataSourceKey());
		this.jdbcTemplate = new JdbcTemplate(ds);
		dbInfo = connectionInfo.getDbInfo();
	}

	private static class PlanRow
	{
		public String stmtText;
		public int stmtId;
		public int nodeId;
		public int parent;
		public String PhysicalOp;
		public String LogicalOp;
		public double EstimateIo;
		public double EstimateCpu;
		public double totalSubtreeCost;
		public Map<String, String> properties = Maps.newHashMap();
		public List<PlanRow> children = Lists.newArrayList();
	}
}
